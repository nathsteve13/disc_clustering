# -*- coding: utf-8 -*-
"""disc_clustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y6W6yzDQiLHByRKOIvLsWMGNJVZ4y_1Y
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.spatial.distance import pdist, squareform
from itertools import combinations
from scipy.cluster.hierarchy import dendrogram, linkage, fcluster
from sklearn.model_selection import train_test_split
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA
from sklearn.metrics import accuracy_score, confusion_matrix
from sklearn.decomposition import PCA

df = pd.read_excel("datadisc.xlsx")

df.head()

#correlation analysis
columns_selected = df.iloc[:,1:]
corr_matrix = columns_selected.corr()

sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Heatmap Corr')
plt.show()

features = df.columns[1:]
x = df.loc[:, features].values

pca = PCA()
pca.fit(x)

plt.figure(figsize=(10, 6))
plt.plot(range(1, len(features) + 1), pca.explained_variance_ratio_.cumsum(), marker='o', linestyle='--')
plt.title('Cumulative Explained Variance by PCA Components')
plt.xlabel('Number of Principal Components')
plt.ylabel('Cumulative Explained Variance')
plt.grid()
plt.show()

eigenvalues, eigenvectors = np.linalg.eig(corr_matrix)
print("Eigen value: ")
print(eigenvalues)

total_variance = np.sum(eigenvalues)

proportion = eigenvalues/total_variance
cum_proportion = np.cumsum(proportion)
print("Proportion of Variance Explained by Each Principal Component:")
print(cum_proportion)

# Performing PCA with 12 components
n_components = 12
pca = PCA(n_components=n_components)
principalComponents = pca.fit_transform(x)
principalDf = pd.DataFrame(data=principalComponents, columns=[f'PC{i+1}' for i in range(n_components)])


# Visualizing the loadings
loadings = pca.components_.T
loadings_df = pd.DataFrame(loadings, columns=[f'PC{i+1}' for i in range(n_components)], index=features)

# Plotting loadings for each principal component separately
for i in range(n_components):
    plt.figure(figsize=(12, 6))
    sns.barplot(x=loadings_df.index, y=loadings_df[f'PC{i+1}'])
    plt.title(f'Loadings for Principal Component {i+1}')
    plt.xlabel('Features')
    plt.ylabel('Loadings')
    plt.xticks(rotation=90)
    plt.show()

"""![image.png](data:image/png;base64,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)"""

def calculate_pca_scores_without_standardization(file_path, sheet_name=None):
    features = df.columns[1:]
    x = df.loc[:, features].values

    pca = PCA()
    principalComponents = pca.fit_transform(x)
    eigenvalues = pca.explained_variance_

    selected_components = [i for i, ev in enumerate(eigenvalues) if ev >= 1]
    if len(selected_components) < len(eigenvalues):
        first_component_with_ev_less_than_1 = min(i for i, ev in enumerate(eigenvalues) if ev < 1)
        selected_components.append(first_component_with_ev_less_than_1)
        selected_components = sorted(selected_components)

    reduced_principalComponents = principalComponents[:, selected_components]
    reduced_loadings = pca.components_[selected_components, :]

    principalDf = pd.DataFrame(data=reduced_principalComponents, columns=[f'PC{i+1}' for i in selected_components])

    finalDf = pd.concat([df[['Nama']], principalDf], axis=1)

    loadings_df = pd.DataFrame(reduced_loadings.T, columns=[f'PC{i+1}' for i in selected_components], index=features)

    for i, name in enumerate(df['Nama']):
        print(f"Data Point: {name}")
        for j in selected_components:
            pc_score = principalDf.iloc[i, selected_components.index(j)]
            terms = " + ".join([f"{x[i, k]:.2f}*{loadings_df.iloc[k, selected_components.index(j)]:.2f}" for k in range(len(features))])
            formula = f"PC{j+1} = {pc_score:.2f} = {terms}"
            print(formula)
        print()

    return finalDf, loadings_df

file_path = 'datadisc.xlsx'
finalDf, loadings_df = calculate_pca_scores_without_standardization(file_path)

finalDf.to_excel('pca_results.xlsx', index=False)

df_pca = pd.read_excel('pca_results.xlsx')
df_pca.head()

#calculate euclidean distance
columns_selected_pca = df_pca.iloc[:,1:]
distances = pdist(columns_selected_pca, metric='euclidean')
distance_matrix = squareform(distances)
print(distance_matrix)

distance_df = pd.DataFrame(distance_matrix)
distance_df.to_csv('distance_matrix.csv', index=False)

distance_df.head()

#dendrogram (hierarchical) clustering analysis
linked = linkage(distances, method='average')

plt.figure(figsize=(10, 7))
dendrogram(linked,
           orientation='top',
           labels=df_pca['Nama'].values,
           distance_sort='descending',
           show_leaf_counts=True)

plt.axhline(y=5, color='r', linestyle='--') #tingkat kemiripan

plt.title('Dendrogram')
plt.xlabel('Nama')
plt.ylabel('Tingkat Simmilarity (Kesamaan)')
plt.show()

cluster_labels = fcluster(linked, 3, criterion='maxclust') #jumlah klaster
finalDf['Cluster'] = cluster_labels
finalDf.to_csv('cluster_labels.csv', index=False)

data_cluster = pd.read_csv('cluster_labels.csv')
data_cluster.drop(columns=['Nama'], inplace=True)
average_per_cluster = data_cluster.groupby('Cluster').mean()

print(average_per_cluster)
average_per_cluster.to_csv('average_per_cluster.csv', index=False)

features = df.columns[1:]
x = df.loc[:, features].values

pca = PCA(n_components=5)
pca.fit(x)
loadings = pca.components_.T

mean_original = np.mean(x, axis=0)

average_original_per_cluster = np.dot(average_per_cluster, loadings.T) + mean_original

average_original_per_cluster_df = pd.DataFrame(data=average_original_per_cluster, columns=features)
average_original_per_cluster_df.index = average_per_cluster.index

print(average_original_per_cluster_df)

average_original_per_cluster_df.to_csv('average_per_cluster_original.csv', index=True)

cluster_sizes = finalDf['Cluster'].value_counts()
if (cluster_sizes == 1).any():
  lda = 0
else:
  lda = 1

print(lda)

cluster_df = pd.read_csv('cluster_labels.csv')
cluster_df.head()

if lda == 1:
  features = cluster_df.columns[1:]
  x = finalDf.loc[:, finalDf.columns[1:-1]].values
  y = finalDf['Cluster'].values

  n_classes = len(pd.unique(y))
  n_components = min(n_classes - 1, len(features))

  # Performing LDA
  lda = LDA(n_components=n_components)
  lda_components = lda.fit_transform(x, y)

  lda_columns = [f'LD{i+1}' for i in range(n_components)]
  lda_df = pd.DataFrame(data=lda_components, columns=lda_columns)
  lda_df = pd.concat([lda_df, df[['Nama']]], axis=1)

  # Visualizing the LDA results with text annotations and offsets
  plt.figure(figsize=(14, 10))
  for i, label in enumerate(df['Nama'].unique()):
      points = plt.scatter(lda_df.loc[lda_df['Nama'] == label, 'LD1'],
                          lda_df.loc[lda_df['Nama'] == label, 'LD2'],
                          label=label)

  plt.xlabel('LD1')
  plt.ylabel('LD2')
  plt.title('LDA of Dataset')
  plt.legend(loc='upper right', bbox_to_anchor=(1.15, 1), borderaxespad=0.)
  plt.grid(True)
  plt.show()

  lda_df.to_csv('lda_results.csv', index=False)
  lda_df.head()

  y_true = finalDf['Cluster'].values

  def map_clusters_to_labels(cluster_labels, true_labels):
      label_map = {}
      for cluster in set(cluster_labels):
          mask = cluster_labels == cluster
          true_label = pd.Series(true_labels[mask]).mode()[0]
          label_map[cluster] = true_label
      return label_map

  # Map the cluster labels to the true labels
  label_map = map_clusters_to_labels(cluster_labels, y_true)
  mapped_labels = [label_map[cluster] for cluster in cluster_labels]

  # Calculate accuracy
  accuracy = accuracy_score(y_true, mapped_labels)
  conf_matrix = confusion_matrix(y_true, mapped_labels)

  print(f"Accuracy: {accuracy}")
  print("Confusion Matrix:")
  print(conf_matrix)

  centroids = lda_df.groupby('Cluster').mean().loc[:, ['LD1', 'LD2']]

  lda_df['Distance_to_Centroid'] = lda_df.apply(
      lambda row: np.linalg.norm(row[['LD1', 'LD2']].values - centroids.loc[row['Cluster']].values), axis=1
  )

  lda_df['Fit'] = np.exp(-lda_df['Distance_to_Centroid'])

  lda_df.to_csv('/mnt/data/lda_results_with_fit.csv', index=False)
  tools.display_dataframe_to_user(name="LDA Results with Fit Scores", dataframe=lda_df)

  print(lda_df)

else:
  print("The minimum num of each clusters is 2")